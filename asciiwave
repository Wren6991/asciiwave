#!/usr/bin/env python3

import json5
import sys

graphics = zip(
	" ┌─┐┏┓x_╱ ╲┆╭┄  ",
	"─┘ └┛┗x ╲ ╱┆  ╰┄"
)

state_map = dict(zip("0+1-rfxz< >|UuDd", graphics))

class StringStream:
	def __init__(self, s):
		self._s = s
		self._offs = 0

	def peek(self, n):
		n = min(n, len(self._s) - self._offs)
		return self._s[self._offs:self._offs + n]

	def get(self, n):
		substr = self.peek(n)
		self._offs += n
		return substr

	def __len__(self):
		return len(self._s) - self._offs


def put_state(outs, state):
	for i, c in enumerate(state_map[state]):
		outs[i] += c

# WaveDrom behaviour is surprisingly complex; this is an approximation
def cmd_10(cmd, prev_cmd, width, charwidth, data, outs):
	h_cmds = "1hHu"
	l_cmds = "0lLd"
	high = cmd in h_cmds
	hard_edge = cmd in "HL" or \
		(high and prev_cmd in (l_cmds + "zx=2345")) or \
		(not high and prev_cmd in (h_cmds + "zx=2345")) or \
		(cmd in "1h" and prev_cmd in "1pP") or \
		(cmd in "0l" and prev_cmd in "0nN")
	if cmd == "u":
		edge, flat = ("U", "u")
	elif cmd == "d":
		edge, flat = ("D", "d")
	elif cmd == "H":
		edge, flat = ("r", "1")
	elif cmd == "L":
		edge, flat = ("f", "0")
	elif high:
		edge, flat = ("+", "1")
	else:
		edge, flat = ("-", "0")
	rendered = edge * hard_edge + flat * (width - hard_edge)
	for s in rendered:
		put_state(outs, s)

def cmd_clk(cmd, prev_cmd, width, charwidth, data, outs):
	shape = {
		"p": "+1-0",
		"P": "r1-0",
		"n": "-0+1",
		"N": "f0+1"
	}[cmd]	
	if (cmd == "p" and prev_cmd in "hH") or (cmd == "n" and prev_cmd in "lL"):
		shape = shape[1] + shape[1:]
	for i in range(width // charwidth):
		put_state(outs, shape[0])
		for j in range(charwidth // 2 - 1):
			put_state(outs, shape[1])
		put_state(outs, shape[2])
		for j in range(charwidth // 2 - 1):
			put_state(outs, shape[3])

def cmd_bus(cmd, prev_cmd, width, charwidth, data, outs):
	assert(cmd in "=2345")
	if len(data) > 0:
		contents = data.pop(0)
	else:
		contents = ""
	space = width - 2
	contents = contents[:min(len(contents), space)]
	contents = "{: ^{}}".format(contents, space)
	put_state(outs, "<")
	for c in contents:
		for i in range(len(outs)):
			outs[i] += c if i == len(outs) // 2 else " "
	put_state(outs, ">")

def cmd_separator(cmd, prev_cmd, width, charwidth, data, outs):
	put_state(outs, "|")


def cmd_other(cmd, prev_cmd, width, charwidth, data, outs):
	assert(cmd in "zZxX")
	for i in range(width):
		put_state(outs, cmd.lower())

cmd_handlers = {}
for c in "1hHu0lLd":
	cmd_handlers[c] = cmd_10
for c in "pPnN":
	cmd_handlers[c] = cmd_clk
for c in "=2345":
	cmd_handlers[c] = cmd_bus
for c in "xXzZ":
	cmd_handlers[c] = cmd_other
cmd_handlers["|"] = cmd_separator

def render_signal(wave, data, charwidth):
	assert(charwidth >=4 and charwidth % 2 == 0)
	outs = [""] * len(state_map[" "])
	wstream = StringStream(wave)
	if type(data) is str:
		data = data.split()
	else:
		data = data[:]
	prev_cmd = "x"
	while len(wstream):
		cmd = wstream.get(1)
		if cmd == ".":
			cmd = prev_cmd
		if cmd not in cmd_handlers:
			cmd = "x"
		width = charwidth
		# WD edge case: . refers to command before separator
		while cmd != "|" and wstream.peek(1) == ".":
			wstream.get(1)
			width += charwidth
		cmd_handlers[cmd](cmd, prev_cmd, width, charwidth, data, outs)
		if cmd != "|":
			prev_cmd = cmd
	return outs

def render_json(s):
	obj = json5.loads(s)
	assert(type(obj) is dict)
	# First pass: basic validation, and get longest name
	for k in obj:
		assert(k in ["config", "signal"])
	try:
		hscale = int(obj["config"]["hscale"] * 2 + 2)
	except KeyError:
		hscale = 6
	max_name_len = 0
	for s in obj["signal"]:
		assert(type(s) is dict)
		for k in s:
			assert(k in ["name", "wave", "data", "period", "phase"])
		if "name" in s:
			max_name_len = max(max_name_len, len(s["name"]))
	# Second pass: actually render
	for s in obj["signal"]:
		if len(s) == 0:
			print("")
			continue
		name = s["name"] if "name" in s else ""
		name_just = "{: <{}}: ".format(name, max_name_len)
		try:
			charwidth = int(s["period"] * hscale)
		except KeyError:
			charwidth = hscale
		if "phase" in s:
			lead = int(s["phase"] * charwidth)
		else:
			lead = 0
		lag = max(-lead, 0)
		lead = max(lead, 0)
		sig_lines = render_signal(s["wave"], s["data"] if "data" in s else [], charwidth)
		for i, l in enumerate(sig_lines):
			if i == len(state_map[" "]) - 1:
				sys.stdout.write(name_just + " " * lag)
			else:
				sys.stdout.write(" " * (len(name_just) + lag))
			print(l[lead:])

if __name__ == "__main__":
	render_json(open(sys.argv[1]).read())
