#!/usr/bin/env python3

import json5
import sys

graphics = zip(
	" ┌─┐┏┓x_╱ ╲┆",
	"─┘ └┛┗x ╲ ╱┆"
)

state_map = dict(zip("0+1-rfxz< >|", graphics))

class StringStream:
	def __init__(self, s):
		self._s = s
		self._offs = 0

	def peek(self, n):
		n = min(n, len(self._s) - self._offs)
		return self._s[self._offs:self._offs + n]

	def get(self, n):
		substr = self.peek(n)
		self._offs += n
		return substr

	def __len__(self):
		return len(self._s) - self._offs

def put_state(outs, state):
	for i, c in enumerate(state_map[state]):
		outs[i] += c

def render_signal(wave, data, charwidth):
	assert(charwidth >=4 and charwidth % 2 == 0)
	outs = [""] * len(state_map[" "])
	wstream = StringStream(wave)

	while len(wstream):
		cmd = wstream.get(1)
		if cmd == ".":
			cmd = "x"
		width = charwidth
		while wstream.peek(1) == ".":
			wstream.get(1)
			width += charwidth

		if cmd in "1hH":
			put_state(outs, "r" if cmd == "H" else "+")
			for i in range(width - 1):
				put_state(outs, "1")
		elif cmd in "0lL":
			put_state(outs, "f" if cmd == "L" else "-")
			for i in range(width - 1):
				put_state(outs, "0")
		elif cmd in "pPnN":
			shape = {
				"p": "+1-0",
				"P": "r1-0",
				"n": "-0+1",
				"N": "f0+1"
			}[cmd]
			for i in range(width // charwidth):
				put_state(outs, shape[0])
				for j in range(charwidth // 2 - 1):
					put_state(outs, shape[1])
				put_state(outs, shape[2])
				for j in range(charwidth // 2 - 1):
					put_state(outs, shape[3])
		elif cmd in "xXzZ":
			for i in range(charwidth):
				put_state(outs, cmd.lower())
		elif cmd in "=2345":
			if len(data) > 0:
				contents = data.pop(0)
			else:
				contents = ""
			space = width - 2
			contents = contents[:min(len(contents), space)]
			contents = "{: ^{}}".format(contents, space)
			put_state(outs, "<")
			for c in contents:
				for i in range(len(outs)):
					outs[i] += c if i == len(outs) // 2 else " "
			put_state(outs, ">")
		elif cmd == "|":
			put_state(outs, "|")

	return outs

def render_json(s):
	obj = json5.loads(s)
	assert(type(obj) is dict)
	# First pass: basic validation, and get longest name
	for k in obj:
		assert(k in ["config", "signal"])
	max_name_len = 0
	for s in obj["signal"]:
		assert(type(s) is dict)
		for k in s:
			assert(k in ["name", "wave", "data"])
		if "name" in s:
			max_name_len = max(max_name_len, len(s["name"]))
	# Second pass: actually render
	for s in obj["signal"]:
		if len(s) == 0:
			print("")
			continue
		name_just = "{: <{}}: ".format(s["name"], max_name_len)
		sig_lines = render_signal(s["wave"], s["data"] if "data" in s else [], 6)
		for i, l in enumerate(sig_lines):
			if i == len(state_map[" "]) - 1:
				sys.stdout.write(name_just)
			else:
				sys.stdout.write(" " * len(name_just))
			print(l)

if __name__ == "__main__":
	render_json(open(sys.argv[1]).read())
